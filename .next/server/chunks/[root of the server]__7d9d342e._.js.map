{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 164, "column": 0}, "map": {"version":3,"sources":["file:///home/fr/atendente-bot/src/app/api/services/evolution/constants.ts"],"sourcesContent":["export enum ENUM_EVOLUTION_CONNECTION_STATE {\n    OPEN = 'open',\n    CLOSE = 'close',\n    NOT_FOUND = 'not_found'\n}"],"names":[],"mappings":";;;AAAO,IAAA,AAAK,yDAAA;;;;WAAA","debugId":null}},
    {"offset": {"line": 179, "column": 0}, "map": {"version":3,"sources":["file:///home/fr/atendente-bot/src/constants.ts"],"sourcesContent":["export const ENVS = {\n  evolutionBaseUrl: process.env.EVOLUTION_BASE_URL,\n  evolutionApiKey: process.env.EVOLUTION_API_KEY,\n  mongoUrl: process.env.MONGO_URL,\n  webhookSendMessageUrl: process.env.WEBHOOK_SEND_MESSAGE_URL,\n  openAiBaseUrl: process.env.OPEN_AI_BASE_URL,\n  openAiApiKey: process.env.OPEN_AI_API_KEY,\n  stripeCallbackUrl: process.env.STRIPE_CALLBACK_URL,\n  stripeApiCompleteKey: process.env.STRIPE_API_COMPLETE_KEY,\n  stripePriceKey: process.env.STRIPE_PRICE_KEY\n};\n\nexport const AUTH_CODE_LOCAL_STORAGE_KEY = 'AUTH_CODE_LOCAL_STORAGE_KEY';\nexport const TELEPHONE_LOCAL_STORAGE_KEY = 'TELEPHONE_LOCAL_STORAGE_KEY';\n\nexport const COLORS = {\n  main: '#009CFF',\n  mainLow: '#9DD9FF',\n  red: '#FF0000'\n};"],"names":[],"mappings":";;;;;;AAAO,MAAM,OAAO;IAClB,kBAAkB,QAAQ,GAAG,CAAC,kBAAkB;IAChD,iBAAiB,QAAQ,GAAG,CAAC,iBAAiB;IAC9C,UAAU,QAAQ,GAAG,CAAC,SAAS;IAC/B,uBAAuB,QAAQ,GAAG,CAAC,wBAAwB;IAC3D,eAAe,QAAQ,GAAG,CAAC,gBAAgB;IAC3C,cAAc,QAAQ,GAAG,CAAC,eAAe;IACzC,mBAAmB,QAAQ,GAAG,CAAC,mBAAmB;IAClD,sBAAsB,QAAQ,GAAG,CAAC,uBAAuB;IACzD,gBAAgB,QAAQ,GAAG,CAAC,gBAAgB;AAC9C;AAEO,MAAM,8BAA8B;AACpC,MAAM,8BAA8B;AAEpC,MAAM,SAAS;IACpB,MAAM;IACN,SAAS;IACT,KAAK;AACP","debugId":null}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"sources":["file:///home/fr/atendente-bot/src/app/api/services/evolution/index.ts"],"sourcesContent":["import axios, { AxiosInstance } from 'axios';\nimport { EvolutionConnectionStateReturn, EvolutionFetchInstanceElementReturn, EvolutionInstanceConnectReturn, EvolutionNewInstanceBody, EvolutionNewMessageBody } from './interfaces';\nimport { ENUM_EVOLUTION_CONNECTION_STATE } from './constants';\nimport { ENVS } from '@/constants';\n\nexport class EvolutionService {\n  private static httpClient: AxiosInstance = axios.create({\n    baseURL: ENVS.evolutionBaseUrl,\n    headers: {\n      'apiKey': ENVS.evolutionApiKey\n    }\n  });\n\n  static async getState (instanceName: string): Promise<EvolutionConnectionStateReturn> {\n    const path: string = `instance/connectionState/${instanceName}`;\n    try {\n      const response: EvolutionConnectionStateReturn = (await this.httpClient.get(path)).data;\n      return response;\n    } catch {\n      return {instance: { instanceName, state: ENUM_EVOLUTION_CONNECTION_STATE.NOT_FOUND }};\n    }\n  }\n\n  static async newInstance (params: EvolutionNewInstanceBody) {\n    const path: string = 'instance/create';\n\n    try {\n      await this.httpClient.post(path, params);\n    } catch {\n      throw new Error(path);\n    }\n  }\n\n  static async instanceConnect (instanceName: string): Promise<EvolutionInstanceConnectReturn> {\n    const path: string =  `instance/connect/${instanceName}`;\n\n    try {\n      const response: EvolutionInstanceConnectReturn = (await this.httpClient.get(path, { params: { number: instanceName } })).data;\n\n      if (!response.code || !response.base64 || !response.pairingCode) {\n        throw new Error(`${path}: Evolution codes not generated!`);\n      }\n\n      return response;\n    } catch {\n      throw new Error(path);\n    }\n  }\n\n  static async sendMessage (instanceName: string, params: EvolutionNewMessageBody) {\n    const path: string = `message/sendText/${instanceName}`;\n\n    try {\n      await this.httpClient.post(path, params);\n    } catch {\n      throw new Error(path);\n    }\n  }\n\n  static async deleteInstance (instanceName: string) {\n    const path: string = `instance/delete/${instanceName}`;\n\n    try {\n      await this.httpClient.delete(path);\n    } catch {\n      throw new Error(path);\n    }\n  }\n\n  static async logoutInstance (instanceName: string) {\n    const path: string = `instance/logout/${instanceName}`;\n\n    try {\n      await this.httpClient.delete(path);\n    } catch {\n      throw new Error(path);\n    }\n  }\n\n  static async fetchInstance (instanceName: string): Promise<EvolutionFetchInstanceElementReturn[]> {\n    const path: string = 'instance/fetchInstances';\n\n    try {\n      const response: EvolutionFetchInstanceElementReturn[] = (await this.httpClient.get(path, { params: { instanceName } })).data;\n\n      return response;\n    } catch {\n      throw new Error(path);\n    }\n  }\n}"],"names":[],"mappings":";;;AAAA;AAEA;AACA;;;;AAEO,MAAM;IACX,OAAe,aAA4B,uIAAA,CAAA,UAAK,CAAC,MAAM,CAAC;QACtD,SAAS,kHAAA,CAAA,OAAI,CAAC,gBAAgB;QAC9B,SAAS;YACP,UAAU,kHAAA,CAAA,OAAI,CAAC,eAAe;QAChC;IACF,GAAG;IAEH,aAAa,SAAU,YAAoB,EAA2C;QACpF,MAAM,OAAe,CAAC,yBAAyB,EAAE,cAAc;QAC/D,IAAI;YACF,MAAM,WAA2C,CAAC,MAAM,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI;YACvF,OAAO;QACT,EAAE,OAAM;YACN,OAAO;gBAAC,UAAU;oBAAE;oBAAc,OAAO,yJAAA,CAAA,kCAA+B,CAAC,SAAS;gBAAC;YAAC;QACtF;IACF;IAEA,aAAa,YAAa,MAAgC,EAAE;QAC1D,MAAM,OAAe;QAErB,IAAI;YACF,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM;QACnC,EAAE,OAAM;YACN,MAAM,IAAI,MAAM;QAClB;IACF;IAEA,aAAa,gBAAiB,YAAoB,EAA2C;QAC3F,MAAM,OAAgB,CAAC,iBAAiB,EAAE,cAAc;QAExD,IAAI;YACF,MAAM,WAA2C,CAAC,MAAM,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM;gBAAE,QAAQ;oBAAE,QAAQ;gBAAa;YAAE,EAAE,EAAE,IAAI;YAE7H,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,SAAS,MAAM,IAAI,CAAC,SAAS,WAAW,EAAE;gBAC/D,MAAM,IAAI,MAAM,GAAG,KAAK,gCAAgC,CAAC;YAC3D;YAEA,OAAO;QACT,EAAE,OAAM;YACN,MAAM,IAAI,MAAM;QAClB;IACF;IAEA,aAAa,YAAa,YAAoB,EAAE,MAA+B,EAAE;QAC/E,MAAM,OAAe,CAAC,iBAAiB,EAAE,cAAc;QAEvD,IAAI;YACF,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM;QACnC,EAAE,OAAM;YACN,MAAM,IAAI,MAAM;QAClB;IACF;IAEA,aAAa,eAAgB,YAAoB,EAAE;QACjD,MAAM,OAAe,CAAC,gBAAgB,EAAE,cAAc;QAEtD,IAAI;YACF,MAAM,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC;QAC/B,EAAE,OAAM;YACN,MAAM,IAAI,MAAM;QAClB;IACF;IAEA,aAAa,eAAgB,YAAoB,EAAE;QACjD,MAAM,OAAe,CAAC,gBAAgB,EAAE,cAAc;QAEtD,IAAI;YACF,MAAM,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC;QAC/B,EAAE,OAAM;YACN,MAAM,IAAI,MAAM;QAClB;IACF;IAEA,aAAa,cAAe,YAAoB,EAAkD;QAChG,MAAM,OAAe;QAErB,IAAI;YACF,MAAM,WAAkD,CAAC,MAAM,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM;gBAAE,QAAQ;oBAAE;gBAAa;YAAE,EAAE,EAAE,IAAI;YAE5H,OAAO;QACT,EAAE,OAAM;YACN,MAAM,IAAI,MAAM;QAClB;IACF;AACF","debugId":null}},
    {"offset": {"line": 315, "column": 0}, "map": {"version":3,"sources":["file:///home/fr/atendente-bot/src/app/api/infra/mongoDb/index.ts"],"sourcesContent":["import { ENVS } from '@/constants';\nimport mongoose from 'mongoose';\n\nconst MONGO_URI = ENVS.mongoUrl;\n\nif (!MONGO_URI) {\n  throw new Error('⚠️ MONGO_URI não foi definida no .env');\n}\n\nexport const connectDB = async (): Promise<void> => {\n  if (mongoose.connection.readyState >= 1) {\n  }\n\n  await mongoose.connect(MONGO_URI);\n};\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEA,MAAM,YAAY,kHAAA,CAAA,OAAI,CAAC,QAAQ;AAE/B,IAAI,CAAC,WAAW;IACd,MAAM,IAAI,MAAM;AAClB;AAEO,MAAM,YAAY;IACvB,IAAI,yGAAA,CAAA,UAAQ,CAAC,UAAU,CAAC,UAAU,IAAI,GAAG,CACzC;IAEA,MAAM,yGAAA,CAAA,UAAQ,CAAC,OAAO,CAAC;AACzB","debugId":null}},
    {"offset": {"line": 336, "column": 0}, "map": {"version":3,"sources":["file:///home/fr/atendente-bot/src/app/api/repositories/client/index.ts"],"sourcesContent":["import { Client, GetClientByTelephoneResponse } from './interfaces';\nimport ClientModel from './models/client';\n\nexport class ClientRepository {\n  private clientModel: typeof ClientModel;\n  private connect: () => Promise<void>;\n\n  constructor(clientModel: typeof ClientModel, connect: () => Promise<void>) {\n    this.clientModel = clientModel;\n    this.connect = connect;\n    this.connect();\n  }\n\n  async upsert(client: Client) {\n    try {\n      const filter = { telephone: client.telephone };\n  \n      const options = { upsert: true, new: true };\n  \n      const updatedClient = await this.clientModel.findOneAndUpdate(filter, client, options);\n  \n      return updatedClient;\n    } catch (error) {\n      throw new Error('Client not created or updated!', { cause: error });\n    }\n  }\n\n  async getByTelephone(telephone: string): Promise<GetClientByTelephoneResponse> {\n    try {\n      const client: GetClientByTelephoneResponse | null = await this.clientModel.findOne({ telephone });\n\n      if (!client) throw new Error('Client not found!');\n\n      return client;\n\n    } catch (error) {\n      const errorMessage = (error as Error).message;\n      throw new Error(errorMessage);\n    }\n  }\n\n  async deleteByTelephone(telephone: string) {\n    try {\n      const response = await this.clientModel.deleteOne({ telephone });\n\n      if (response.deletedCount === 0) throw new Error('None deleted!');\n    } catch {\n      throw new Error('It was not possible delete user by db!');\n    }\n  }\n  \n  async decrementClientTokens(clientId: string) {\n    try {\n      const response = await this.clientModel.updateOne({ _id: clientId }, { $inc: { messageTokens: -1 }});\n\n      if (response.modifiedCount === 0 ) throw new Error('None updated!');\n    } catch {\n      throw new Error('It was not possible decrement user tokens!');\n    }\n  }\n\n  async incrementClientTokens(clientId: string, qty: number) {\n    try {\n      const response = await this.clientModel.updateOne({ _id: clientId }, { $inc: { messageTokens: qty }});\n\n      if (response.modifiedCount === 0 ) throw new Error('None updated!');\n    } catch {\n      throw new Error('It was not possible increment user tokens!');\n    }\n  }\n}\n"],"names":[],"mappings":";;;AAGO,MAAM;IACH,YAAgC;IAChC,QAA6B;IAErC,YAAY,WAA+B,EAAE,OAA4B,CAAE;QACzE,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,OAAO;IACd;IAEA,MAAM,OAAO,MAAc,EAAE;QAC3B,IAAI;YACF,MAAM,SAAS;gBAAE,WAAW,OAAO,SAAS;YAAC;YAE7C,MAAM,UAAU;gBAAE,QAAQ;gBAAM,KAAK;YAAK;YAE1C,MAAM,gBAAgB,MAAM,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,QAAQ,QAAQ;YAE9E,OAAO;QACT,EAAE,OAAO,OAAO;YACd,MAAM,IAAI,MAAM,kCAAkC;gBAAE,OAAO;YAAM;QACnE;IACF;IAEA,MAAM,eAAe,SAAiB,EAAyC;QAC7E,IAAI;YACF,MAAM,SAA8C,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC;gBAAE;YAAU;YAE/F,IAAI,CAAC,QAAQ,MAAM,IAAI,MAAM;YAE7B,OAAO;QAET,EAAE,OAAO,OAAO;YACd,MAAM,eAAe,AAAC,MAAgB,OAAO;YAC7C,MAAM,IAAI,MAAM;QAClB;IACF;IAEA,MAAM,kBAAkB,SAAiB,EAAE;QACzC,IAAI;YACF,MAAM,WAAW,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC;gBAAE;YAAU;YAE9D,IAAI,SAAS,YAAY,KAAK,GAAG,MAAM,IAAI,MAAM;QACnD,EAAE,OAAM;YACN,MAAM,IAAI,MAAM;QAClB;IACF;IAEA,MAAM,sBAAsB,QAAgB,EAAE;QAC5C,IAAI;YACF,MAAM,WAAW,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC;gBAAE,KAAK;YAAS,GAAG;gBAAE,MAAM;oBAAE,eAAe,CAAC;gBAAE;YAAC;YAElG,IAAI,SAAS,aAAa,KAAK,GAAI,MAAM,IAAI,MAAM;QACrD,EAAE,OAAM;YACN,MAAM,IAAI,MAAM;QAClB;IACF;IAEA,MAAM,sBAAsB,QAAgB,EAAE,GAAW,EAAE;QACzD,IAAI;YACF,MAAM,WAAW,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC;gBAAE,KAAK;YAAS,GAAG;gBAAE,MAAM;oBAAE,eAAe;gBAAI;YAAC;YAEnG,IAAI,SAAS,aAAa,KAAK,GAAI,MAAM,IAAI,MAAM;QACrD,EAAE,OAAM;YACN,MAAM,IAAI,MAAM;QAClB;IACF;AACF","debugId":null}},
    {"offset": {"line": 421, "column": 0}, "map": {"version":3,"sources":["file:///home/fr/atendente-bot/src/app/api/repositories/client/models/client.ts"],"sourcesContent":["import mongoose, { Document, Schema } from 'mongoose';\nimport { Client } from '../interfaces';\n\nconst ClientSchema: Schema<Client & Document> = new Schema(\n  {\n    telephone: { type: String, required: true },\n    authCode: { type: String, required: true },\n    messageTokens: { type: Number, required: false },\n  },\n  { timestamps: true }\n);\n\nconst ClientModel = mongoose.models.Client || mongoose.model<Client>('Client', ClientSchema);\n\nexport default ClientModel;\n"],"names":[],"mappings":";;;AAAA;;AAGA,MAAM,eAA0C,IAAI,yGAAA,CAAA,SAAM,CACxD;IACE,WAAW;QAAE,MAAM;QAAQ,UAAU;IAAK;IAC1C,UAAU;QAAE,MAAM;QAAQ,UAAU;IAAK;IACzC,eAAe;QAAE,MAAM;QAAQ,UAAU;IAAM;AACjD,GACA;IAAE,YAAY;AAAK;AAGrB,MAAM,cAAc,yGAAA,CAAA,UAAQ,CAAC,MAAM,CAAC,MAAM,IAAI,yGAAA,CAAA,UAAQ,CAAC,KAAK,CAAS,UAAU;uCAEhE","debugId":null}},
    {"offset": {"line": 450, "column": 0}, "map": {"version":3,"sources":["file:///home/fr/atendente-bot/src/app/api/repositories/info/index.ts"],"sourcesContent":["import { Info, InfoRepositoryRepresentation } from './interfaces';\nimport InfoModel from './models/info';\n\nexport class InfoRepository {\n  private infoModel: typeof InfoModel;\n  private connect: () => Promise<void>;\n\n  constructor(infoModel: typeof InfoModel, connect: () => Promise<void>) {\n    this.infoModel = infoModel;\n    this.connect = connect;\n    this.connect();\n  }\n\n  async create(client: Info) {\n    try {\n      await this.infoModel.insertOne(client);\n    } catch (error) {\n      throw new Error('Info not created!', { cause: error });\n    }\n  }\n\n  async update(client: Partial<Info>, infoId: string) {\n    try {\n      const response = await this.infoModel.updateOne({ _id: infoId }, client);\n\n      if (response.modifiedCount === 0) {\n        throw new Error('None updated!');\n      }\n    } catch (error) {\n      throw new Error('Info not updated!', { cause: error });\n    }\n  }\n\n  async delete(infoId: string) {\n    try {\n      const response = await this.infoModel.deleteOne({ _id: infoId });\n\n      if (response.deletedCount === 0) {\n        throw new Error('None deleted!');\n      }\n\n    } catch (error) {\n      throw new Error('Info not deleted!', { cause: error });\n    }\n  }\n\n  async getAllByClientId(clientId: string): Promise<InfoRepositoryRepresentation[]> {\n    try {\n      const response: InfoRepositoryRepresentation[] = await this.infoModel.find({ clientId });\n\n      if (response.length === 0) {\n        throw new Error('None info founded!');\n      }\n\n      return response;\n    } catch (error) {\n      throw new Error(`Infos of ${clientId} not founded!`, { cause: error });\n    }\n  }\n}\n"],"names":[],"mappings":";;;AAGO,MAAM;IACH,UAA4B;IAC5B,QAA6B;IAErC,YAAY,SAA2B,EAAE,OAA4B,CAAE;QACrE,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,OAAO;IACd;IAEA,MAAM,OAAO,MAAY,EAAE;QACzB,IAAI;YACF,MAAM,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC;QACjC,EAAE,OAAO,OAAO;YACd,MAAM,IAAI,MAAM,qBAAqB;gBAAE,OAAO;YAAM;QACtD;IACF;IAEA,MAAM,OAAO,MAAqB,EAAE,MAAc,EAAE;QAClD,IAAI;YACF,MAAM,WAAW,MAAM,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC;gBAAE,KAAK;YAAO,GAAG;YAEjE,IAAI,SAAS,aAAa,KAAK,GAAG;gBAChC,MAAM,IAAI,MAAM;YAClB;QACF,EAAE,OAAO,OAAO;YACd,MAAM,IAAI,MAAM,qBAAqB;gBAAE,OAAO;YAAM;QACtD;IACF;IAEA,MAAM,OAAO,MAAc,EAAE;QAC3B,IAAI;YACF,MAAM,WAAW,MAAM,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC;gBAAE,KAAK;YAAO;YAE9D,IAAI,SAAS,YAAY,KAAK,GAAG;gBAC/B,MAAM,IAAI,MAAM;YAClB;QAEF,EAAE,OAAO,OAAO;YACd,MAAM,IAAI,MAAM,qBAAqB;gBAAE,OAAO;YAAM;QACtD;IACF;IAEA,MAAM,iBAAiB,QAAgB,EAA2C;QAChF,IAAI;YACF,MAAM,WAA2C,MAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;gBAAE;YAAS;YAEtF,IAAI,SAAS,MAAM,KAAK,GAAG;gBACzB,MAAM,IAAI,MAAM;YAClB;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,MAAM,IAAI,MAAM,CAAC,SAAS,EAAE,SAAS,aAAa,CAAC,EAAE;gBAAE,OAAO;YAAM;QACtE;IACF;AACF","debugId":null}},
    {"offset": {"line": 520, "column": 0}, "map": {"version":3,"sources":["file:///home/fr/atendente-bot/src/app/api/repositories/info/models/info.ts"],"sourcesContent":["import mongoose, { Document, Schema } from 'mongoose';\nimport { Info } from '../interfaces';\n\nconst InfoSchema: Schema<Info & Document> = new Schema(\n  {\n    title: { type: String, required: true },\n    description: { type: String, required: true },\n    clientId:{ type: String, required: true },\n  },\n  { timestamps: true }\n);\n\nconst InfoModel = mongoose.models.Info || mongoose.model<Info>('Info', InfoSchema);\n\nexport default InfoModel;\n"],"names":[],"mappings":";;;AAAA;;AAGA,MAAM,aAAsC,IAAI,yGAAA,CAAA,SAAM,CACpD;IACE,OAAO;QAAE,MAAM;QAAQ,UAAU;IAAK;IACtC,aAAa;QAAE,MAAM;QAAQ,UAAU;IAAK;IAC5C,UAAS;QAAE,MAAM;QAAQ,UAAU;IAAK;AAC1C,GACA;IAAE,YAAY;AAAK;AAGrB,MAAM,YAAY,yGAAA,CAAA,UAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,yGAAA,CAAA,UAAQ,CAAC,KAAK,CAAO,QAAQ;uCAExD","debugId":null}},
    {"offset": {"line": 549, "column": 0}, "map": {"version":3,"sources":["file:///home/fr/atendente-bot/src/app/api/client/helpers/index.ts"],"sourcesContent":["import { ENVS } from '@/constants';\nimport { EvolutionService } from '../../services/evolution';\nimport { ENUM_EVOLUTION_CONNECTION_STATE } from '../../services/evolution/constants';\nimport { EvolutionInstanceConnectReturn } from '../../services/evolution/interfaces';\nimport { InfoRepositoryRepresentation } from '../../repositories/info/interfaces';\nimport { connectDB } from '../../infra/mongoDb';\nimport { ClientRepository } from '../../repositories/client';\nimport ClientModel from '../../repositories/client/models/client';\nimport { InfoRepository } from '../../repositories/info';\nimport InfoModel from '../../repositories/info/models/info';\nimport { GetClientByTelephoneResponse } from '../../repositories/client/interfaces';\n\nexport const validadeInstanceStateAndGenerateQrCode = async (\n  telephone: string\n): Promise<EvolutionInstanceConnectReturn> => {\n  const state: ENUM_EVOLUTION_CONNECTION_STATE = (await EvolutionService.getState(telephone)).instance.state;\n\n  const tryConnect = async (): Promise<EvolutionInstanceConnectReturn> => {\n    try {\n      return await EvolutionService.instanceConnect(telephone);\n    } catch {\n      throw new Error('Não foi possível gerar o qr-code!');\n    }\n  };\n\n  switch (state) {\n  case ENUM_EVOLUTION_CONNECTION_STATE.OPEN:\n    throw new Error('Esse telofone já está conectado!');\n\n  case ENUM_EVOLUTION_CONNECTION_STATE.CLOSE:\n    return await tryConnect();\n\n  case ENUM_EVOLUTION_CONNECTION_STATE.NOT_FOUND:\n    try {\n      await EvolutionService.newInstance({\n        instanceName: telephone,\n        integration: 'WHATSAPP-BAILEYS',\n        number: telephone,\n        qrcode: true,\n        token: telephone,\n        webhook: {\n          webhookByEvents: true,\n          events: ['MESSAGES_UPSERT', 'CONNECTION_UPDATE'],\n          url: ENVS.webhookSendMessageUrl || ''\n        }\n      });\n      return await tryConnect();\n    } catch {\n      throw new Error('Não foi possível gerar o qr-code durante a criação da instância!');\n    }\n\n  default:\n    EvolutionService.deleteInstance(telephone);\n    throw new Error('Erro inesperado!');\n  }\n};\n\nexport const getInfosOfClientByTelephone = async (telephone: string): Promise<InfoRepositoryRepresentation[]> => {\n  const clientRepository = new ClientRepository(ClientModel, connectDB);\n  const infoRepository = new InfoRepository(InfoModel, connectDB);\n  try {\n    const client: GetClientByTelephoneResponse = await clientRepository.getByTelephone(telephone);\n    const clientInfos: InfoRepositoryRepresentation[] = await infoRepository.getAllByClientId(client._id);\n\n    return clientInfos;\n  } catch  {\n    return [];\n  }\n};"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;AAGO,MAAM,yCAAyC,OACpD;IAEA,MAAM,QAAyC,CAAC,MAAM,qJAAA,CAAA,mBAAgB,CAAC,QAAQ,CAAC,UAAU,EAAE,QAAQ,CAAC,KAAK;IAE1G,MAAM,aAAa;QACjB,IAAI;YACF,OAAO,MAAM,qJAAA,CAAA,mBAAgB,CAAC,eAAe,CAAC;QAChD,EAAE,OAAM;YACN,MAAM,IAAI,MAAM;QAClB;IACF;IAEA,OAAQ;QACR,KAAK,yJAAA,CAAA,kCAA+B,CAAC,IAAI;YACvC,MAAM,IAAI,MAAM;QAElB,KAAK,yJAAA,CAAA,kCAA+B,CAAC,KAAK;YACxC,OAAO,MAAM;QAEf,KAAK,yJAAA,CAAA,kCAA+B,CAAC,SAAS;YAC5C,IAAI;gBACF,MAAM,qJAAA,CAAA,mBAAgB,CAAC,WAAW,CAAC;oBACjC,cAAc;oBACd,aAAa;oBACb,QAAQ;oBACR,QAAQ;oBACR,OAAO;oBACP,SAAS;wBACP,iBAAiB;wBACjB,QAAQ;4BAAC;4BAAmB;yBAAoB;wBAChD,KAAK,kHAAA,CAAA,OAAI,CAAC,qBAAqB,IAAI;oBACrC;gBACF;gBACA,OAAO,MAAM;YACf,EAAE,OAAM;gBACN,MAAM,IAAI,MAAM;YAClB;QAEF;YACE,qJAAA,CAAA,mBAAgB,CAAC,cAAc,CAAC;YAChC,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,MAAM,8BAA8B,OAAO;IAChD,MAAM,mBAAmB,IAAI,sJAAA,CAAA,mBAAgB,CAAC,iKAAA,CAAA,UAAW,EAAE,gJAAA,CAAA,YAAS;IACpE,MAAM,iBAAiB,IAAI,oJAAA,CAAA,iBAAc,CAAC,6JAAA,CAAA,UAAS,EAAE,gJAAA,CAAA,YAAS;IAC9D,IAAI;QACF,MAAM,SAAuC,MAAM,iBAAiB,cAAc,CAAC;QACnF,MAAM,cAA8C,MAAM,eAAe,gBAAgB,CAAC,OAAO,GAAG;QAEpG,OAAO;IACT,EAAE,OAAO;QACP,OAAO,EAAE;IACX;AACF","debugId":null}},
    {"offset": {"line": 626, "column": 0}, "map": {"version":3,"sources":["file:///home/fr/atendente-bot/src/app/api/services/open-ai/constants.ts"],"sourcesContent":["export enum ENUM_OPEN_AI_INPUT_ROLES {\n    USER = 'user',\n    DEVELOPER = 'developer'\n}"],"names":[],"mappings":";;;AAAO,IAAA,AAAK,kDAAA;;;WAAA","debugId":null}},
    {"offset": {"line": 640, "column": 0}, "map": {"version":3,"sources":["file:///home/fr/atendente-bot/src/app/api/services/open-ai/index.ts"],"sourcesContent":["import axios, { AxiosInstance } from 'axios';\nimport { ENVS } from '@/constants';\nimport { OpenAiGetResponseReturn, OpenAiInputContent, OpenAiParamsBody } from './interfaces';\nimport { ENUM_OPEN_AI_INPUT_ROLES } from './constants';\n\nexport class OpenAIService {\n  private static httpClient: AxiosInstance = axios.create({\n    baseURL: ENVS.openAiBaseUrl,\n    headers: {\n      'Authorization': `Bearer ${ENVS.openAiApiKey}`\n    }\n  });\n\n  private static iaContext = `Como um atendente feliz da loja, respondo todas as perguntas com base nas informações fornecidas. \n  Se a mensagem não estiver relacionada a esses dados, informarei que não há informações disponíveis. Minhas respostas sempre estarão \n  dentro do escopo de atendimento e das informações disponíveis, sem abordar assuntos fora desse contexto! Pode adicionar emojis nas \n  respostas, deixar bem humanizado.`;\n\n  static async getResponse (infosClient: OpenAiInputContent[], userMessage: string): Promise<OpenAiGetResponseReturn> {\n    const path: string = 'v1/responses';\n    const body: OpenAiParamsBody = {\n      model: 'gpt-4o',\n      input: [\n        {\n          role: ENUM_OPEN_AI_INPUT_ROLES.DEVELOPER,\n          content: [{ type: 'input_text', text: this.iaContext }]\n        }, \n        { role: ENUM_OPEN_AI_INPUT_ROLES.DEVELOPER, content: infosClient },\n        { role: ENUM_OPEN_AI_INPUT_ROLES.USER, content: [{ type: 'input_text', text: userMessage }] }\n      ],\n      text: {\n        format: {\n          type: 'text'\n        }\n      },\n      reasoning: {},\n      tools: [],\n      temperature: 1,\n      max_output_tokens: 2048,\n      top_p: 1,\n      store: true\n    };\n    try {\n      const response: OpenAiGetResponseReturn = (await this.httpClient.post(path, body)).data;\n      return response;\n    } catch {\n      throw new Error(path);\n    }\n  }\n}"],"names":[],"mappings":";;;AAAA;AACA;AAEA;;;;AAEO,MAAM;IACX,OAAe,aAA4B,uIAAA,CAAA,UAAK,CAAC,MAAM,CAAC;QACtD,SAAS,kHAAA,CAAA,OAAI,CAAC,aAAa;QAC3B,SAAS;YACP,iBAAiB,CAAC,OAAO,EAAE,kHAAA,CAAA,OAAI,CAAC,YAAY,EAAE;QAChD;IACF,GAAG;IAEH,OAAe,YAAY,CAAC;;;mCAGK,CAAC,CAAC;IAEnC,aAAa,YAAa,WAAiC,EAAE,WAAmB,EAAoC;QAClH,MAAM,OAAe;QACrB,MAAM,OAAyB;YAC7B,OAAO;YACP,OAAO;gBACL;oBACE,MAAM,0JAAA,CAAA,2BAAwB,CAAC,SAAS;oBACxC,SAAS;wBAAC;4BAAE,MAAM;4BAAc,MAAM,IAAI,CAAC,SAAS;wBAAC;qBAAE;gBACzD;gBACA;oBAAE,MAAM,0JAAA,CAAA,2BAAwB,CAAC,SAAS;oBAAE,SAAS;gBAAY;gBACjE;oBAAE,MAAM,0JAAA,CAAA,2BAAwB,CAAC,IAAI;oBAAE,SAAS;wBAAC;4BAAE,MAAM;4BAAc,MAAM;wBAAY;qBAAE;gBAAC;aAC7F;YACD,MAAM;gBACJ,QAAQ;oBACN,MAAM;gBACR;YACF;YACA,WAAW,CAAC;YACZ,OAAO,EAAE;YACT,aAAa;YACb,mBAAmB;YACnB,OAAO;YACP,OAAO;QACT;QACA,IAAI;YACF,MAAM,WAAoC,CAAC,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,KAAK,EAAE,IAAI;YACvF,OAAO;QACT,EAAE,OAAM;YACN,MAAM,IAAI,MAAM;QAClB;IACF;AACF","debugId":null}},
    {"offset": {"line": 714, "column": 0}, "map": {"version":3,"sources":["file:///home/fr/atendente-bot/src/app/api/client/webhook-send-message/messages-upsert/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { WebhookMessageEventBody } from '../../interfaces';\nimport { EvolutionService } from '../../../services/evolution';\nimport { getInfosOfClientByTelephone } from '../../helpers';\nimport { InfoRepositoryRepresentation } from '../../../repositories/info/interfaces';\nimport { OpenAIService } from '../../../services/open-ai';\nimport { OpenAiInputContent } from '../../../services/open-ai/interfaces';\nimport { ClientRepository } from '../../../repositories/client';\nimport ClientModel from '../../../repositories/client/models/client';\nimport { connectDB } from '../../../infra/mongoDb';\n\nconst clientRepository = new ClientRepository(ClientModel, connectDB);\n\nexport async function POST(req: Request) {\n  try {\n    const body: WebhookMessageEventBody = await req.json();\n    const client = await clientRepository.getByTelephone(body.instance);\n\n    if (client.messageTokens === 0) return NextResponse.json({ message: 'O cliente não possui tokens suficientes!' }, { status: 403 });\n\n    if(!body.data.key.fromMe && body.data.key.remoteJid.includes('@s.whatsapp.net')) {\n\n      const clientInfos: InfoRepositoryRepresentation[] = await getInfosOfClientByTelephone(body.instance);\n\n      if (clientInfos.length === 0) {\n        await EvolutionService.\n          sendMessage(body.instance, { number: body.data.key.remoteJid.replace('@s.whatsapp.net', ''), text: 'Nenhuma informação disponível!' });\n        return NextResponse.json({}, { status: 201 });\n      }\n\n      const chatGPTInputs: OpenAiInputContent[] = clientInfos.map(info => ({ type: 'input_text', text: `${info.title}: ${info.description}` }));\n      const chatGPTResponse = await OpenAIService.getResponse(chatGPTInputs, body.data.message.conversation);\n\n      await EvolutionService.\n        sendMessage(body.instance, { \n          number: body.data.key.remoteJid.replace('@s.whatsapp.net', ''), \n          text: chatGPTResponse.output[0].content[0].text\n        });\n      await clientRepository.decrementClientTokens(client._id);\n      return NextResponse.json({}, { status: 201 });\n    }\n\n    return NextResponse.json({}, { status: 400 });\n  } catch {\n    return NextResponse.json({ message: 'Nenhum dado enviado!' }, { status: 400 });\n  }\n}\n\n"],"names":[],"mappings":";;;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AACA;;;;;;;;AAEA,MAAM,mBAAmB,IAAI,sJAAA,CAAA,mBAAgB,CAAC,iKAAA,CAAA,UAAW,EAAE,gJAAA,CAAA,YAAS;AAE7D,eAAe,KAAK,GAAY;IACrC,IAAI;QACF,MAAM,OAAgC,MAAM,IAAI,IAAI;QACpD,MAAM,SAAS,MAAM,iBAAiB,cAAc,CAAC,KAAK,QAAQ;QAElE,IAAI,OAAO,aAAa,KAAK,GAAG,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAA2C,GAAG;YAAE,QAAQ;QAAI;QAEhI,IAAG,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC,MAAM,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,QAAQ,CAAC,oBAAoB;YAE/E,MAAM,cAA8C,MAAM,CAAA,GAAA,iJAAA,CAAA,8BAA2B,AAAD,EAAE,KAAK,QAAQ;YAEnG,IAAI,YAAY,MAAM,KAAK,GAAG;gBAC5B,MAAM,qJAAA,CAAA,mBAAgB,CACpB,WAAW,CAAC,KAAK,QAAQ,EAAE;oBAAE,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,OAAO,CAAC,mBAAmB;oBAAK,MAAM;gBAAiC;gBACtI,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC,CAAC,GAAG;oBAAE,QAAQ;gBAAI;YAC7C;YAEA,MAAM,gBAAsC,YAAY,GAAG,CAAC,CAAA,OAAQ,CAAC;oBAAE,MAAM;oBAAc,MAAM,GAAG,KAAK,KAAK,CAAC,EAAE,EAAE,KAAK,WAAW,EAAE;gBAAC,CAAC;YACvI,MAAM,kBAAkB,MAAM,sJAAA,CAAA,gBAAa,CAAC,WAAW,CAAC,eAAe,KAAK,IAAI,CAAC,OAAO,CAAC,YAAY;YAErG,MAAM,qJAAA,CAAA,mBAAgB,CACpB,WAAW,CAAC,KAAK,QAAQ,EAAE;gBACzB,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,OAAO,CAAC,mBAAmB;gBAC3D,MAAM,gBAAgB,MAAM,CAAC,EAAE,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI;YACjD;YACF,MAAM,iBAAiB,qBAAqB,CAAC,OAAO,GAAG;YACvD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC,CAAC,GAAG;gBAAE,QAAQ;YAAI;QAC7C;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC,CAAC,GAAG;YAAE,QAAQ;QAAI;IAC7C,EAAE,OAAM;QACN,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAuB,GAAG;YAAE,QAAQ;QAAI;IAC9E;AACF","debugId":null}}]
}